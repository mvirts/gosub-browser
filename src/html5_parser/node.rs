use std::fmt;

// A DOM node that has been generated by the parser.
pub struct Node<'a> {
    value: &'a str,
    children: Vec<Node<'a>>,
}

impl<'a> Node<'a> {
    pub fn new(value: &'a str) -> Self {
        Node {
            value,
            children: Vec::new(),
        }
    }

    pub fn add_child(&mut self, child: Node<'a>) {
        self.children.push(child)
    }
}


impl<'a> fmt::Debug for Node<'a> {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        // Helper function to recursively format nodes with indentation
        fn format_node(node: &Node, f: &mut fmt::Formatter, indent: usize) -> fmt::Result {
            // Write the current node's value with the current indentation
            writeln!(f, "{:indent$}{}", "", node.value, indent = indent)?;

            // If there are children, recursively format them with increased indentation
            for child in &node.children {
                format_node(child, f, indent + 2)?; // Increase indentation by 2 spaces for children
            }
            Ok(())
        }

        // Start formatting from the current node with 0 indentation
        format_node(self, f, 0)
    }
}

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn test_nodes() {
        let mut n = Node::new("foo");
        assert_eq!(n.value, "foo");
        assert_eq!(n.children.len(), 0);

        let n2 = Node::new("bar");
        let n3 = Node::new("baz");
        n.add_child(n2);
        n.add_child(n3);
        assert_eq!(n.children.len(), 2);

        assert_eq!(n.children[0].value, "bar");
        assert_eq!(n.children[0].children.len(), 0);

        assert_eq!(n.children[1].value, "baz");
        assert_eq!(n.children[1].children.len(), 0);
    }
}
